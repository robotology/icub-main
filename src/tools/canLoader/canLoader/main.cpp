// -*- mode:C++; tab-width:4; c-basic-offset:4; indent-tabs-mode:nil -*-

/*
 * Copyright (C) 2008 RobotCub Consortium
 * Author: Marco Maggiali, Marco Randazzo, Alessandro Scalzo
 * CopyPolicy: Released under the terms of the GNU GPL v2.0.
 *
 */

/**
*
@ingroup icub_tools
@ingroup icub_guis
\defgroup icub_canLoader canLoader

Use this application to download your firmware in DSP boards.

\section intro_sec Description
CanLoder20 is a YARP/GTK based application that allows the firmware update of the DSP boards of iCub.
The board types currently supported by the CanLoader application are:
- MC4     (Motorola 56807 DSP for control of bushed CC motors)
- BLL     (Motorola 56807 DSP for control of brushless motors)
- STRAIN (DSPIC 30f4013 6 axis force/torque sensor)
- MAIS     (DSPIC 30f4013 Hall-effect position sensor)
_ SKIN   (DSPIC 30f4011 Tactile Sensor board)
In order to successfully transfer the firmware to the boards using the CanLoader application, the desired boards
must be powered on and properly connected to the CAN Bus using either the 'ecan' or 'pcan' or 'cfw2can' or 'socketcan' CAN Bus driver,
or, alternatively, canLoader can program the boards connected to a EMS board.
The CanLoader application can run in two different modalities:
- Graphical User Interface (GUI) modality:
This modality allows the user to examinate the status of the DSP boards detected on the specified CAN Bus, to download
the firmware to multiple bords and to change other settings, such as the individual CAN addresses or the identification labels.
- Command line modality:
This modality allows to the user to update the firmware of one DSP board in a fast and scriptable way.
The application requires in input a set of parameters (specified in the parameters section) in order to identify the board to be updated.
The application returns a value that specifies the result of the download.

\section lib_sec Libraries
YARP libraries.
GTK libraries.

\section parameters_sec Parameters
You can use the canLoader application in two ways: using a GUI or by command line.
The GUI is executed by default if the canLoader application is launched without parameters.
For example:
./canLoader
executes the graphical version of the canLoader.

To use the canLoader application by command line, without the graphical interface, use the following syntax:
./canLoader --canDeviceType t --canDeviceNum x --boardId y --firmware myFirmware.out.S
./canLoader --canDeviceType EMS --canDeviceNum 1|2 --boardId y --firmware myFirmware.out.S --boardIPAddr aaa.aaa.aaa.aaa
All of the parameters are mandatory. A description of the parameters follows:
--canDeviceType t: specifies the type of canBusDriver used. The parameter t can assume the values 'ecan' or 'pcan' or 'cfw2can' or 'socketcan'
--canDeviceNum x: specifies the canBus identification number. The parameter x can be 0,1,2 or 3.
--boardId y: specifies the can address of the board on which the firmware will be downloaded. The parameter y ranges from 1 to 15.
--firmware myFirmware.out.S: specifies the file name containing the firmware (binary code) that will be downloaded.
--boardIPAddr aaa.aaa.aaa.aaa: it is the EMS board IP address.

\section portsa_sec Ports Accessed
None

\section portsc_sec Ports Created
None

\section in_files_sec Input Data Files
The canLoader application requires in input a file containing the firmware that will be downloaded.
The extension of the firmware file is typically '.out.s' for the Motorola DSP-based boards and '.hex' fot DSPIC-based boards.
The name of the file containing the firmware is specified using the --firmware parameter if the canLoader application is executed by command line
or browsing the directories if the GUI is used.

\section out_data_sec Output Data Files
No output files are generated by the canLoader application.

If the application is executed using the command line modality, the following codes are retuned by the application, identifying the status (success or not) of the download.

#define ALL_OK                        0

#define INVALID_CMD_STRING           -1

#define INVALID_PARAM_CANTYPE        -2

#define INVALID_PARAM_CANNUM         -3

#define INVALID_PARAM_BOARDID        -4

#define INVALID_PARAM_FILE           -5

#define ERR_NO_BOARDS_FOUND         -10

#define ERR_BOARD_ID_NOT_FOUND      -11

#define ERR_UNKNOWN                 -12

#define DOWNLOADERR_NOT_CONNECTED   -20

#define DOWNLOADERR_BOARD_NOT_SEL   -21

#define DOWNLOADERR_FILE_NOT_SEL    -22

#define DOWNLOADERR_FILE_NOT_OPEN   -23

#define DOWNLOADERR_BOARD_NOT_START -24

#define DOWNLOADERR_TRANSFER_ERROR  -25

In this way, an external script that invokes the canLoader application can check the result of the firmware download operation.


\section conf_file_sec Configuration Files
The canLoader application uses a configuration file (config.txt) located in the same diretory of the executable.
The configuration file specifies the filename of the firmware used in the last download operation.
If the configuration file is not found when the canLoader application is executed in graphical modality, a new config.txt is generated.
The configuration file is not used when the canLoader is executed in command line modality.

\section tested_os_sec Tested OS
Linux and Windows.

\section example_sec Example Instantiation of the Module
canLoader
canLoader --help
canLoader --canDeviceType esd --canDeviceNum 2 --boardId 1 --firmware myFirmware.out.S
canLoader --canDeviceType EMS --canDeviceNum 1 --boardId 4 --firmware myFirmware.out.S --boardIPAddr 10.0.1.8

\author Marco Randazzo

Copyright (C) 2008 RobotCub Consortium

CopyPolicy: Released under the terms of the GNU GPL v2.0.

This file can be edited at src/myModule/main.cpp.
**/

#include "downloader.h"
#include "ethDriver.h"
#include "calibrate_window.h"
#include <gtk/gtk.h>
#include <gtk/gtkmain.h>
#include <yarp/os/Time.h>
#include <yarp/dev/Drivers.h>

#include <string>   //stl string
#include <string.h> //memcpy ...
#include <stdlib.h>

#include <stdio.h>
#include <fcntl.h>

#include <canProtocolLib/iCubCanProtocol.h>
#include <canProtocolLib/iCubCanProto_types.h>

YARP_DECLARE_DEVICES(icubmod)

GtkWidget *window     = NULL;

GtkWidget *vbox_main         = NULL;
GtkWidget *main_vbox         = NULL;
GtkWidget *top_hbox             = NULL;
GtkWidget *bottom_hbox       = NULL;
GtkWidget *start_end_button  = NULL;
GtkWidget *combo_netId       = NULL;
GtkWidget *combo_netType     = NULL;
GtkWidget *combo_canId       = NULL;
GtkWidget *box_ipAddr        = NULL;
GtkWidget *progress_bar      = NULL;
GtkWidget *inv1              = NULL;

GtkWidget *vbox_board_list   = NULL;
GtkWidget *vbox_board_list2  = NULL;
GtkWidget *panel_hbox        = NULL;
GtkWidget *label             = NULL;
GtkWidget *sw                = NULL;

GtkWidget *message_icon         = NULL;
GtkWidget *message_hbox         = NULL;
GtkWidget *message_right_vbox = NULL;
GtkWidget *message_label1     = NULL;
GtkWidget *message_label2     = NULL;

GtkWidget *treeview          = NULL;
GtkWidget *button1           = NULL;
GtkWidget *button2           = NULL;
GtkWidget *download_button   = NULL;
GtkWidget *calibrate_button  = NULL;

GtkWidget *picker            = NULL;
GtkWidget *message           = NULL;
//GtkWidget *deviceNameEntry   = NULL;

cDownloader downloader;

//can_parameters_type params;
int networkId=0;
int canID=1;
unsigned int  localAddr=0;
unsigned int remoteAddr=0;
const int maxNetworks=10; //max number of can networks
std::string networkType;
bool calibration_enabled=false;
bool prompt_version=false;

enum
{
    COLUMN_SELECTED,
    COLUMN_ID,
    COLUMN_TYPE,
    COLUMN_VERSION,
    COLUMN_RELEASE,
    COLUMN_BUILD,
    COLUMN_SERIAL,
    COLUMN_STATUS,
    COLUMN_ADD_INFO,
    COLUMN_EEPROM,
    NUM_COLUMNS
};

#define ALL_OK                         0
#define INVALID_CMD_STRING            -1
#define INVALID_PARAM_CANTYPE        -2
#define INVALID_PARAM_CANNUM        -3
#define INVALID_PARAM_BOARDID        -4
#define INVALID_PARAM_FILE            -5
#define ERR_NO_BOARDS_FOUND            -10
#define ERR_BOARD_ID_NOT_FOUND      -11
#define ERR_UNKNOWN                    -12
#define ERR_NO_NETWORK_INTERFACE     -13
#define DOWNLOADERR_NOT_CONNECTED    -20
#define DOWNLOADERR_BOARD_NOT_SEL    -21
#define DOWNLOADERR_FILE_NOT_SEL    -22
#define DOWNLOADERR_FILE_NOT_OPEN   -23
#define DOWNLOADERR_BOARD_NOT_START -24
#define DOWNLOADERR_TRANSFER_ERROR    -25

//*********************************************************************************
static GtkTreeModel * refresh_board_list_model (void)
{

    gint i = 0;
    GtkListStore *store;
    GtkTreeIter iter;

    // create list store
    store = gtk_list_store_new ( NUM_COLUMNS,
        G_TYPE_BOOLEAN,
        G_TYPE_UINT,
        G_TYPE_STRING,
        G_TYPE_STRING,
        G_TYPE_STRING,
        G_TYPE_STRING,
        G_TYPE_STRING,
        G_TYPE_STRING,
        G_TYPE_STRING,
        G_TYPE_BOOLEAN
        );

    char board_type        [50]; memset (board_type,0,50);
    char board_status   [50]; memset (board_status,0,50);
    char board_add_info    [50]; memset (board_add_info,0,50);
    char board_version    [10]; memset (board_version,0,10);
    char board_release    [10]; memset (board_release,0,10);
    char board_build    [10]; memset (board_build,0,10);
    char board_serial   [10]; memset (board_serial,0,10);

    // add data to the list store
    for (i = 0; i < downloader.board_list_size; i++)
    {
        switch (downloader.board_list[i].type)
        {
        case icubCanProto_boardType__dsp:
            strcpy(board_type, "RM OLD (DSP)");
            break;
        case icubCanProto_boardType__pic:
            strcpy(board_type, "MPH (PIC)");
            break;
        case icubCanProto_boardType__2dc:
            strcpy(board_type, "RM 2DC (DSP)");
            break;
        case icubCanProto_boardType__4dc:
            strcpy(board_type, "RM 4DC (DSP)");
            break;
        case icubCanProto_boardType__bll:
            strcpy(board_type, "RM BLL (DSP)");
            break;
        case icubCanProto_boardType__skin:
            strcpy(board_type, "SKIN (DSPIC)");
            break;
        case icubCanProto_boardType__strain:
            strcpy(board_type, "STRAIN (DSPIC)");
            break;
        case icubCanProto_boardType__mais:
            strcpy(board_type, "MAIS (DSPIC)");
            break;
        case icubCanProto_boardType__2foc:
            strcpy(board_type, "2FOC (DSPIC)");
            break;
        case icubCanProto_boardType__6sg:
            strcpy(board_type, "6SG (DSPIC)");
            break;
        case icubCanProto_boardType__jog:
            strcpy(board_type, "JOG (DSPIC)");
            break;
        case icubCanProto_boardType__unknown:

        default:
            strcpy(board_type, "UNKNOWN");
            break;
        }

        switch (downloader.board_list[i].status)
        {
        case BOARD_RUNNING:
            strcpy(board_status, "RUNNING");
            break;
        case BOARD_WAITING:
            strcpy(board_status, "WAITING");
            break;
        case BOARD_WAITING_ACK:
            strcpy(board_status, "WAITING_ACK");
            break;
        case BOARD_DOWNLOADING:
            strcpy(board_status, "DOWNLOADING");
            break;
        case BOARD_OK :
            strcpy(board_status, "OK");
            break;
        case BOARD_ERR:
            strcpy(board_status, "ERR");
            break;
        default:
            strcpy(board_status, "UNKNOWN");
            break;
        }

        strncpy  (board_add_info, downloader.board_list[i].add_info,32);
        sprintf (board_version,"%d",downloader.board_list[i].version);
        sprintf (board_release,"%X",downloader.board_list[i].release);
        sprintf (board_build,"%d",downloader.board_list[i].build);
        sprintf (board_serial,"%s",downloader.board_list[i].serial);

        gtk_list_store_append (store, &iter);
        gtk_list_store_set (store, &iter,
            COLUMN_SELECTED, downloader.board_list[i].selected,
            COLUMN_ID, downloader.board_list[i].pid,
            COLUMN_TYPE, board_type,
            COLUMN_VERSION, board_version,
            COLUMN_RELEASE, board_release,
            COLUMN_BUILD, board_build,
            COLUMN_SERIAL, board_serial,
            COLUMN_STATUS, board_status,
            COLUMN_ADD_INFO, board_add_info,
            COLUMN_EEPROM, downloader.board_list[i].eeprom,
            -1);

    }

    return GTK_TREE_MODEL (store);
}
//*********************************************************************************
static GtkTreeModel * create_net_model (void)
{
    gint i = 0;
    GtkListStore *store;
    GtkTreeIter iter;

    // create list store
    store = gtk_list_store_new (1, G_TYPE_STRING);

    // add data to the list store

    for (int k=0;k<maxNetworks;k++)
        {
            char tmp[80];
            sprintf(tmp, "Net %d", k);
            gtk_list_store_append (store, &iter);
            gtk_list_store_set (store, &iter, 0, tmp,-1);
        }

    return GTK_TREE_MODEL (store);
}

//*********************************************************************************
static GtkTreeModel * create_netType_model (void)
{
    gint i = 0;
    GtkListStore *store;
    GtkTreeIter iter;

    // create list store
    store = gtk_list_store_new (1, G_TYPE_STRING);

    // add data to the list store
    gtk_list_store_append (store, &iter);
    gtk_list_store_set (store, &iter, 0, "ecan",-1);
    gtk_list_store_append (store, &iter);
    gtk_list_store_set (store, &iter, 0, "pcan",-1);
    gtk_list_store_append (store, &iter);
    gtk_list_store_set (store, &iter, 0, "cfw2can",-1);
    gtk_list_store_append (store, &iter);
    gtk_list_store_set (store, &iter, 0, "socketcan",-1);
    gtk_list_store_append (store, &iter);
    gtk_list_store_set (store, &iter, 0, "EMS",-1);

    return GTK_TREE_MODEL (store);
}

static GtkTreeModel * create_canId_model (void)
{
    gint i = 0;
    GtkListStore *store;
    GtkTreeIter iter;

    // create list store
    store = gtk_list_store_new (1, G_TYPE_STRING);

    // add data to the list store
    gtk_list_store_append (store, &iter);
    gtk_list_store_set (store, &iter, 0, "Can 1",-1);
    gtk_list_store_append (store, &iter);
    gtk_list_store_set (store, &iter, 0, "Can 2",-1);

    return GTK_TREE_MODEL (store);
}

//*********************************************************************************
static void combo_netid_changed (GtkComboBox *box,    gpointer   user_data)
{
    int net = gtk_combo_box_get_active (box);
    networkId=net;
}

//*********************************************************************************
static void combo_nettype_changed (GtkComboBox *box,    gpointer   user_data)
{
    int net = gtk_combo_box_get_active (box);
    switch (net)
    {
        case  0:
            networkType = "ecan";
            gtk_widget_set_sensitive (combo_netId, true);
            gtk_widget_set_sensitive (combo_canId, false);
            gtk_widget_set_sensitive (box_ipAddr, false);
            break;

        case  1:
            networkType = "pcan";
            gtk_widget_set_sensitive (combo_netId, true);
            gtk_widget_set_sensitive (combo_canId, false);
            gtk_widget_set_sensitive (box_ipAddr, false);
            break;

        case  2:
            networkType="cfw2can";
            gtk_widget_set_sensitive (combo_netId, true);
            gtk_widget_set_sensitive (combo_canId, false);
            gtk_widget_set_sensitive (box_ipAddr, false);
            break;

        case  3:
            networkType="socketcan";
            gtk_widget_set_sensitive (combo_netId, true);
            gtk_widget_set_sensitive (combo_canId, false);
            gtk_widget_set_sensitive (box_ipAddr, false);
            break;

        case  4: networkType="EMS";
            gtk_widget_set_sensitive (combo_netId, false);
            gtk_widget_set_sensitive (combo_canId, true);
            gtk_widget_set_sensitive (box_ipAddr, true);
            break;
    }
}

static void combo_canid_changed (GtkComboBox *box,    gpointer   user_data)
{
    int net = gtk_combo_box_get_active (box);
    switch (net)
    {
        case  0: canID = 1; break;
        case  1: canID = 2; break;
    }
}

//*********************************************************************************
// This callback exits from the gtk_main() main loop when the main window is closed
static void finish_download (GtkWidget *wid,    gpointer   user_data)
{
    // Refresh the list of the selected boards
    downloader.initschede();
    gtk_tree_view_set_model (GTK_TREE_VIEW (treeview), refresh_board_list_model());
    gtk_widget_draw(treeview, NULL);

    gtk_widget_destroy (wid);
}

//*********************************************************************************
static void select_all (GtkButton *button,    gpointer   user_data)
{
    for (int i = 0; i < downloader.board_list_size; i++)
    {
        downloader.board_list[i].selected=true;
    }
    gtk_tree_view_set_model (GTK_TREE_VIEW (treeview), refresh_board_list_model());
    gtk_widget_draw(treeview, NULL);
    printf ("all boards selected\n");
}
static void deselect_all (GtkButton *button,    gpointer   user_data)
{
    for (int i = 0; i < downloader.board_list_size; i++)
    {
        downloader.board_list[i].selected=false;
    }
    gtk_tree_view_set_model (GTK_TREE_VIEW (treeview), refresh_board_list_model());
    gtk_widget_draw(treeview, NULL);
    printf ("all boards not selected\n");
}

//*********************************************************************************
void connected_status()
{
    if (prompt_version == true) return;
    gtk_button_set_label     (GTK_BUTTON(start_end_button), "Disconnect");
    gtk_widget_set_sensitive (button1, true);
    gtk_widget_set_sensitive (button2, true);
    gtk_widget_set_sensitive (download_button, true);
    gtk_widget_set_sensitive (treeview, true);
    gtk_widget_set_sensitive (combo_netId, false);
    gtk_widget_set_sensitive (combo_netType, false);
    gtk_widget_set_sensitive (combo_canId, false);
    gtk_widget_set_sensitive (box_ipAddr, false);
    if (calibration_enabled) { gtk_widget_set_sensitive (calibrate_button, false); }
    return;

    //not used now
    GdkColor color;
    color.red=50000;
    color.green=65535;
    color.blue=50000;
    gtk_widget_modify_bg (start_end_button, GTK_STATE_NORMAL,      &color);
    gtk_widget_modify_bg (start_end_button, GTK_STATE_ACTIVE,      &color);
    gtk_widget_modify_bg (start_end_button, GTK_STATE_PRELIGHT,    &color);
    gtk_widget_modify_bg (start_end_button, GTK_STATE_SELECTED,    &color);
    gtk_widget_modify_bg (start_end_button, GTK_STATE_INSENSITIVE, &color);
}

void not_connected_status()
{
    if (prompt_version == true) return;
    gtk_button_set_label     (GTK_BUTTON(start_end_button), "Connect");
    gtk_widget_set_sensitive (button1, false);
    gtk_widget_set_sensitive (button2, false);
    gtk_widget_set_sensitive (download_button, false);
    gtk_widget_set_sensitive (treeview, false);

    gtk_widget_set_sensitive (combo_netId, networkType!="EMS");
    gtk_widget_set_sensitive (combo_netType, true);
    gtk_widget_set_sensitive (combo_canId, networkType=="EMS");
    gtk_widget_set_sensitive (box_ipAddr, networkType=="EMS");
    if (calibration_enabled) { gtk_widget_set_sensitive (calibrate_button, false); }
    return;

    //not used now
    GdkColor color;
    color.red=65535;
    color.green=50000;
    color.blue=50000;
    gtk_widget_modify_bg (start_end_button, GTK_STATE_NORMAL,      &color);
    gtk_widget_modify_bg (start_end_button, GTK_STATE_ACTIVE,      &color);
    gtk_widget_modify_bg (start_end_button, GTK_STATE_PRELIGHT,    &color);
    gtk_widget_modify_bg (start_end_button, GTK_STATE_SELECTED,    &color);
    gtk_widget_modify_bg (start_end_button, GTK_STATE_INSENSITIVE, &color);
}
//*********************************************************************************

//Shows a message dialog for displaying infos/errors
GtkWidget * dialog_message_generator(GtkMessageType gtk_message_type, const char *text1, const char *text2)
{
    GtkWidget *message;

    //message=gtk_message_dialog_new(NULL,GTK_DIALOG_MODAL,gtk_message_type,GTK_BUTTONS_CLOSE, text1);


    if        (gtk_message_type!=GTK_MESSAGE_QUESTION)
    {
        message = gtk_dialog_new_with_buttons ("Interactive Dialog",
            GTK_WINDOW (window),
            GTK_DIALOG_MODAL,
            GTK_STOCK_OK,
            GTK_RESPONSE_OK,
            NULL);
    }
    else
    {
        message = gtk_dialog_new_with_buttons ("Interactive Dialog",
            GTK_WINDOW (window),
            GTK_DIALOG_MODAL,
            GTK_STOCK_YES,
            GTK_RESPONSE_YES,
            GTK_STOCK_NO,
            GTK_RESPONSE_NO,
            NULL);
    }

    /*
    message = gtk_dialog_new ("",
    GTK_WINDOW (window),
    GTK_DIALOG_MODAL,
    NULL);
    */

    gtk_window_set_resizable(GTK_WINDOW(message),false);

    message_hbox = gtk_hbox_new (FALSE, 8);
    gtk_container_set_border_width (GTK_CONTAINER (message_hbox), 8);
    gtk_box_pack_start (GTK_BOX (GTK_DIALOG (message)->vbox), message_hbox, FALSE, FALSE, 0);

    if        (gtk_message_type==GTK_MESSAGE_QUESTION)
    {
        gtk_window_set_title    (GTK_WINDOW(message),"Question");
        message_icon = gtk_image_new_from_stock (GTK_STOCK_DIALOG_QUESTION, GTK_ICON_SIZE_DIALOG);
    }
    else if (gtk_message_type==GTK_MESSAGE_ERROR)
    {
        gtk_window_set_title    (GTK_WINDOW(message),"Error");
        message_icon = gtk_image_new_from_stock (GTK_STOCK_DIALOG_ERROR, GTK_ICON_SIZE_DIALOG);
    }
    else if (gtk_message_type==GTK_MESSAGE_INFO)
    {
        gtk_window_set_title    (GTK_WINDOW(message),"Information");
        message_icon = gtk_image_new_from_stock (GTK_STOCK_DIALOG_INFO, GTK_ICON_SIZE_DIALOG);
    }
    else
    {
        gtk_window_set_title    (GTK_WINDOW(message),"Information");
        message_icon = gtk_image_new_from_stock (GTK_STOCK_DIALOG_INFO, GTK_ICON_SIZE_DIALOG);
    }

    gtk_box_pack_start (GTK_BOX (message_hbox), message_icon, FALSE, FALSE, 0);

    message_right_vbox = gtk_vbox_new (FALSE, 8);
    gtk_container_set_border_width (GTK_CONTAINER (message_right_vbox), 8);
    gtk_box_pack_start (GTK_BOX (message_hbox), message_right_vbox, FALSE, FALSE, 0);

    message_label1 = gtk_label_new (text1);

    gtk_label_set_justify   (GTK_LABEL(message_label1),  GTK_JUSTIFY_LEFT);
    gtk_box_pack_start (GTK_BOX (message_right_vbox), message_label1, FALSE, FALSE, 0);

    if (text2)
    {
        message_label2 = gtk_label_new (text2);

        gtk_label_set_justify   (GTK_LABEL(message_label2),  GTK_JUSTIFY_LEFT);
        gtk_box_pack_start (GTK_BOX (message_right_vbox), message_label2, FALSE, FALSE, 0);
    }

    gtk_widget_show_all (message_hbox);

    //GTK_BUTTONS_YES_NO
    return message;

}
//*********************************************************************************
bool dialog_message (GtkMessageType gtk_message_type, const char *text1, const char *text2, bool connect=true)
{
    if (prompt_version==true) return 0;

    message=dialog_message_generator(gtk_message_type, text1, text2);

    gtk_widget_show(message);
    if (connect)
        g_signal_connect_swapped (message, "response",G_CALLBACK (gtk_widget_destroy), message);

    return 0;
}

//*********************************************************************************
bool dialog_question_additional_field ()
{
    bool ret=false;

    message=dialog_message_generator(GTK_MESSAGE_QUESTION, "Do you really want to change the additional info field of this board?", NULL);
    gint response = gtk_dialog_run (GTK_DIALOG (message));
    if (response == GTK_RESPONSE_YES)
    {
        ret = true;
    }
    else
    {
        ret = false;
    }
    gtk_widget_destroy (message);
    return ret;
}

//*********************************************************************************
bool dialog_question_can_address (gint old_id, gint new_id)
{
    bool ret=false;

    char text [200];
    sprintf (text , "Do you really want to change the can address of this board?\r\n\r\nCURRENT CAN ADDRESS %d WILL BE CHANGED IN %d",old_id,new_id) ;

    message=dialog_message_generator(GTK_MESSAGE_QUESTION, text, NULL);
    gtk_window_set_modal(GTK_WINDOW(message),true);

    gint response = gtk_dialog_run (GTK_DIALOG (message));
    if (response == GTK_RESPONSE_YES)
    {
        ret=true;
    }
    else
    {
        ret=false;
    }
    gtk_widget_destroy (message);
    return ret;
}
//*********************************************************************************

static bool compile_ip_addresses(const char* addr)
{
    ACE_UINT32 ip1,ip2,ip3,ip4;
    //sscanf(gtk_entry_get_text(GTK_ENTRY(box_ipAddr)),"%d.%d.%d.%d",&ip1,&ip2,&ip3,&ip4);
    sscanf(addr,"%d.%d.%d.%d",&ip1,&ip2,&ip3,&ip4);
    remoteAddr=(ip1<<24)|(ip2<<16)|(ip3<<8)|ip4;

    size_t count=0;
    ACE_INET_Addr* addr_array=NULL;
    int ret=ACE::get_ip_interfaces(count,addr_array);

    if (ret || count<=0)
    {
        //dialog_message(GTK_MESSAGE_ERROR,"Init driver failed","Could not find network interface");
        return false;
    }

    localAddr=addr_array[0].get_ip_address();

    for (unsigned int a=1; a<count; ++a)
    {
        if ((remoteAddr & 0xFFFF0000)==(addr_array[a].get_ip_address() & 0xFFFF0000))
        {
            localAddr=addr_array[a].get_ip_address();
            break;
        }
    }

    return true;
}

static void start_end_click (GtkButton *button,    gpointer   user_data)
{
    int ret = 0;

    if (downloader.connected==false)
    {
        yarp::os::Property params;
        params.put("device", networkType.c_str());

        if (networkType=="EMS")
        {
            if (!prompt_version)
            {
                if (!compile_ip_addresses(gtk_entry_get_text(GTK_ENTRY(box_ipAddr))))
                {
                    dialog_message(GTK_MESSAGE_ERROR,"Init driver failed","Could not find network interface");
                    return;
                }
            }

            params.put("local", int( localAddr));
            params.put("remote",int(remoteAddr));
            params.put("canid",canID);
        }
        else
        {
            params.put("canDeviceNum", networkId);
            params.put("canTxQueue", 64);
            params.put("canRxQueue", 64);
            params.put("canTxTimeout", 2000);
            params.put("canRxTimeout", 2000);
        }

        //try to connect to the driver
        ret = downloader.initdriver(params);

        if (ret == -1)
        {
            dialog_message(GTK_MESSAGE_ERROR,"Init driver failed","Hardware busy or not connected?!");
            return;
        }

        //drv_sleep (2000);
        //get the infos from the board
        ret = downloader.initschede();

        if (ret == -1)
        {
            dialog_message(GTK_MESSAGE_INFO,"Communication error","No answers received (no boards found).");
            downloader.stopdriver();
            not_connected_status();
            return;
        }

        if (prompt_version == false)
        {
            gtk_tree_view_set_model (GTK_TREE_VIEW (treeview), refresh_board_list_model());
            gtk_widget_draw(treeview, NULL);
        }

        //enable select/deselect all buttons
        dialog_message(GTK_MESSAGE_INFO,"Driver Connected","");
        connected_status();
    }
    else
    {
        downloader.stopdriver();
        dialog_message(GTK_MESSAGE_INFO,"Driver Stopped","");
        //disable select/deselect all buttons
        not_connected_status();
    }
}

//*********************************************************************************
bool load_calibration (char* filename)
{
    int selected=0;
    int count=0;
    int i=0;
    for (i=0; i<downloader.board_list_size; i++)
    {
        if (downloader.board_list[i].status==BOARD_RUNNING &&
            (downloader.board_list[i].type==icubCanProto_boardType__strain || downloader.board_list[i].type==icubCanProto_boardType__6sg) &&
            downloader.board_list[i].selected==true)
            {
                selected = i;
                count++;
            }
    }
    //only one board can be calibrated!!
    if (count!=1)
    {
        return false;
    }

    if (calibration_load_v2 (filename,downloader.board_list[selected].pid))
    {
        //save to eeprom
        downloader.strain_save_to_eeprom(downloader.board_list[selected].pid);
    }
    return true;
}

//*********************************************************************************
static int download_click (GtkButton *button,    gpointer   user_data)
{
    double timer_start =0;
    double timer_end   =0;
    // check if can driver is running
    if (downloader.connected == false)
    {
        dialog_message(GTK_MESSAGE_ERROR,"Driver not running","Use 'Connect' button to start the driver");
        return DOWNLOADERR_NOT_CONNECTED;
    }

    //check if at least one board was selected
    bool at_least_one_board_selected = false;
    int i        = 0;

    for (i=0; i<downloader.board_list_size; i++)
    {
        if (downloader.board_list[i].status==BOARD_RUNNING &&
            downloader.board_list[i].selected==true)
            at_least_one_board_selected = true;
    }

    if (!at_least_one_board_selected)
    {
        dialog_message(GTK_MESSAGE_ERROR,"No Boards selected!","Select one or more boards to download the firmware");
        return DOWNLOADERR_BOARD_NOT_SEL;
    }

    // Open the selected file
    char* buffer=NULL;

    if (user_data==NULL)
    {
        buffer = gtk_file_chooser_get_filename   (GTK_FILE_CHOOSER(picker));
        if (buffer==NULL)
        {
            dialog_message(GTK_MESSAGE_ERROR,"No files selected!","Select the file You want to download, first");
            return DOWNLOADERR_FILE_NOT_SEL;
        }
    }
    else
    {
        std::string* p = (std::string*)user_data;
        buffer = new char[255];
        strcpy(buffer,(p->c_str()));
    }
    if (downloader.open_file(buffer)!=0)
    {
        dialog_message(GTK_MESSAGE_ERROR,"Error opening the selected file!","");
        return DOWNLOADERR_FILE_NOT_OPEN;
    }

    //@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
    if (strstr (buffer, "calibrationDataSN") != 0)
    {
        load_calibration (buffer);
        return ALL_OK;
    }
    //@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@

    // Get an identification of the firmware fot the file that you have selected
    int firmware_board_type=0;
    int firmware_version=0;
    int firmware_revision=0;
    /*
    // THIS FEATURE IS ONLY EXPERIMENTAL
    //    char substring [10];
    // this is depending on the file name
    if         (strncmp (buffer, "4DC", 3) == 0) {firmware_board_type = BOARD_TYPE_4DC; printf ("opened a 4DC firmware file\n"); }
    else if (strncmp (buffer, "2BL", 3) == 0) {firmware_board_type = BOARD_TYPE_BLL; printf ("opened a BLL firmware file\n"); }
    else if (strncmp (buffer, "2DC", 3) == 0) {firmware_board_type = BOARD_TYPE_2DC; printf ("opened a 2DC firmware file\n"); }
    else                                       {firmware_board_type = BOARD_TYPE_DSP; printf ("opened a generic firmware file\n"); }

    memset(substring, 0, 10);
    strncpy (substring, buffer+4, 1);
    firmware_version = strtol(substring,  NULL, 10);
    printf  ("opened firmware version: %s %d\n", substring, firmware_version);

    memset(substring, 0, 10);
    strncpy (substring, buffer+6, 2);
    firmware_revision = strtol(substring,  NULL, 10);
    printf  ("opened firmware revision: %s\n", substring, firmware_revision);
    */

    //indentify download type from the type of the selected boards
    int download_type = icubCanProto_boardType__unknown;
    bool download_eeprom =false;
    for (i=0; i<downloader.board_list_size; i++)
    {
        if (downloader.board_list[i].selected==true)
        {
            download_type = downloader.board_list[i].type;
            download_eeprom = downloader.board_list[i].eeprom;
        }

    }

    // Start the download for the selected boards
    for (i=0; i<downloader.board_list_size; i++)
    {
        if (downloader.board_list[i].status==BOARD_RUNNING &&
            downloader.board_list[i].selected==true)
        {
            if (downloader.startscheda(downloader.board_list[i].pid,downloader.board_list[i].eeprom,downloader.board_list[i].type)!=0)
            {
                dialog_message(GTK_MESSAGE_ERROR,"Unable to start the board","Unable to send message 'start' or no answer received");
                return DOWNLOADERR_BOARD_NOT_START;
            }
            else
            {
                downloader.board_list[i].status=BOARD_WAITING;
            }
        }
    }

    // Refresh the list of the selected boards
    if (prompt_version == false)
    {
        gtk_tree_view_set_model (GTK_TREE_VIEW (treeview), refresh_board_list_model());
        gtk_widget_draw(treeview, NULL);
        gtk_main_iteration_do (false);
    }

    int ret      = 0;
    int finished = 0;

    timer_start= yarp::os::Time::now();

    bool print00 = false, print25 = false, print50 = false, print75 = false, print99 = false;
    // Start the download for the selected boards
    do
    {
        ret = downloader.download_file(0x0F, download_type,download_eeprom);
        if (float(downloader.progress)/downloader.file_length >0.0  && print00==false)    {printf ("downloading %s, 1%% done\n",buffer); print00=true;}
        if (float(downloader.progress)/downloader.file_length >0.25 && print25==false)    {printf ("downloading %s, 25%% done\n",buffer); print25=true;}
        if (float(downloader.progress)/downloader.file_length >0.50 && print50==false)    {printf ("downloading %s, 50%% done\n",buffer); print50=true;}
        if (float(downloader.progress)/downloader.file_length >0.75 && print75==false)    {printf ("downloading %s, 75%% done\n",buffer); print75=true;}
        if (float(downloader.progress)/downloader.file_length >0.99 && print99==false)    {printf ("downloading %s, finished!\n",buffer); print99=true;}

        if (ret==1)
        {
            //Continuing the download
            if (prompt_version==false && downloader.progress % 50 == 0)
            {
                gtk_progress_bar_set_fraction ((GtkProgressBar*) progress_bar, float(downloader.progress)/downloader.file_length);
                gtk_tree_view_set_model (GTK_TREE_VIEW (treeview), refresh_board_list_model());
                gtk_widget_draw(window, NULL);
                gtk_main_iteration_do (false);
            }
        }
        if (ret==-1)
        {
            //Fatal Error during download, terminate
            finished = 1;
        }
        if (ret==0)
        {
            //Download terminated
            finished = 1;
        }

        // Update the progress bar
        if (prompt_version==false && downloader.progress % 50 == 0)
            {
                gtk_progress_bar_set_fraction ((GtkProgressBar*) progress_bar, 0);
                gtk_tree_view_set_model (GTK_TREE_VIEW (treeview), refresh_board_list_model());
                gtk_widget_draw(treeview, NULL);
                gtk_main_iteration_do (false);
            }
    }
    while (finished!=1);
    timer_end= yarp::os::Time::now();

    // End the download for the selected boards
    int errors =0;
    downloader.stopscheda(15);
/*
    ///@@@ CHECK THE FOLLOWING CODE THAT HAS BEEN REMOVED
    ///    IN ORDER TO STOP THE BOARD AFTER THE DOWNLOAD AN START IMMEDIATELY
    ///    THE EXECUTION OF THE CODE

    //char tmp [100];
    for (i=0; i<downloader.board_list_size; i++)
    {
        if (downloader.board_list[i].selected==true)
        {
            if (downloader.board_list[i].status==BOARD_DOWNLOADING)
            {
                if (downloader.stopscheda(downloader.board_list[i].pid)==0)
                {
                    downloader.board_list[i].status=BOARD_OK;
                    printf("board %d stopped\n",downloader.board_list[i].pid);
                }
                else
                {
                    printf ("Unable to stop board %d",downloader.board_list[i].pid);
                    downloader.board_list[i].status=BOARD_ERR;
                    errors++;
                }
            }
            else if (downloader.board_list[i].status==BOARD_ERR)
            {
               printf ("Board %d: download failed",downloader.board_list[i].pid);
                errors++;
            }
        }
    }
*/
    //Display result message
    if (errors==0)
    {
        char time_text [50];
        double download_time = (timer_end-timer_start) ;
        sprintf (time_text, "All Board OK\nDownload Time (s): %.2f", download_time);
        if (prompt_version == false)
        {
            dialog_message(GTK_MESSAGE_INFO,"Download Finished",time_text,false);
            g_signal_connect_swapped (message, "response",G_CALLBACK (finish_download), message);
            gtk_tree_view_set_model (GTK_TREE_VIEW (treeview), refresh_board_list_model());
            gtk_widget_draw(treeview, NULL);
        }
        return ALL_OK;
    }
    else
    {
        if (prompt_version == false)
        {
            dialog_message(GTK_MESSAGE_ERROR,"Error during file transfer","",false);
            g_signal_connect_swapped (message, "response",G_CALLBACK (finish_download), message);
            gtk_tree_view_set_model (GTK_TREE_VIEW (treeview), refresh_board_list_model());
            gtk_widget_draw(treeview, NULL);
        }
        return DOWNLOADERR_TRANSFER_ERROR;
    }

}

//*********************************************************************************
static void choose_file (GtkFileChooser *picker,    gpointer   user_data)
{
    gchar* path = gtk_file_chooser_get_filename (GTK_FILE_CHOOSER(picker));
    if (path == NULL) return;

    std::fstream filestr;

    filestr.open ("config.txt", std::fstream::out);
    if (filestr.is_open())
    {
        filestr<<path<<std::endl;
        if (calibration_enabled==true) filestr<<"calib"<<std::endl;
        filestr.close();
        filestr.clear();
    }

    // new file has been selected
    printf ("New file has been selected\n");
    g_free (path);
}

//*********************************************************************************
static void
edited_board_id (GtkCellRendererText *cell, gchar *path_str, gchar *new_text, gpointer data)
{
    gint  new_val = atoi (new_text);
    if   (new_val <=0 || new_val> 15) return;
    //---


    //---
    GtkTreeModel *model = gtk_tree_view_get_model (GTK_TREE_VIEW(treeview));
    GtkTreeIter  iter;
    GtkTreePath *path = gtk_tree_path_new_from_string (path_str);


    gint*  old_val = new gint;
    // get toggled iter
    gtk_tree_model_get_iter (model, &iter, path);
    gtk_tree_model_get (model, &iter, COLUMN_ID, old_val,-1);
    int* index;
    index = gtk_tree_path_get_indices (path);

    if (*old_val == new_val)
    {
        delete (old_val);
        return;
    }

    if (dialog_question_can_address(*old_val,new_val))
    {
        downloader.change_card_address(*old_val,new_val,downloader.board_list[index[0]].type);
        delete (old_val);
    }

    gtk_tree_view_set_model (GTK_TREE_VIEW (treeview), refresh_board_list_model());
    gtk_widget_draw(treeview, NULL);

    // clean up
    gtk_tree_path_free (path);
}

//*********************************************************************************
static void
edited_additional_info (GtkCellRendererText *cell, gchar *path_str, gchar *new_text, gpointer data)
{
    GtkTreeModel *model = gtk_tree_view_get_model (GTK_TREE_VIEW(treeview));
    GtkTreeIter  iter;
    GtkTreePath *path = gtk_tree_path_new_from_string (path_str);

    gchar* old_text;
    gint*  board_id = new gint;
    // get toggled iter
    gtk_tree_model_get_iter (model, &iter, path);
    gtk_tree_model_get (model, &iter, COLUMN_ADD_INFO, &old_text,-1);
    gtk_tree_model_get (model, &iter, COLUMN_ID, board_id,-1);

    if (strcmp (old_text, new_text) == 0)
    {
        g_free (old_text);
        delete (board_id);
        return;
    }

    char safe_buffer [32];
    memset (safe_buffer,0,32);
    strncpy (safe_buffer,new_text,32);
    if (dialog_question_additional_field())
    {
        downloader.change_board_info(*board_id, safe_buffer);
        g_free (old_text);
        delete (board_id);
        //      dialog_message(GTK_MESSAGE_ERROR,"operation failed!","Not Yet Implemented! :-)");
    }

    gtk_tree_view_set_model (GTK_TREE_VIEW (treeview), refresh_board_list_model());
    gtk_widget_draw(treeview, NULL);

    // clean up
    gtk_tree_path_free (path);
}

//*********************************************************************************
bool validate_calibration ()
{
    int i=0;
    int count=0;
    for (i=0; i<downloader.board_list_size; i++)
    {
        if (downloader.board_list[i].status==BOARD_RUNNING &&
            (downloader.board_list[i].type==icubCanProto_boardType__strain || downloader.board_list[i].type==icubCanProto_boardType__6sg) &&
            downloader.board_list[i].selected==true)
            {
                count++;
            }
    }

    if (count<1) return false;
    if (count>1) return false;
    return true;
}

//*********************************************************************************
bool validate_selection (int wanted_type)
{
    int first_type = icubCanProto_boardType__unknown;
    bool something_selected=false;
    int i=0;
    for (i=0; i<downloader.board_list_size; i++)
    {
        if (downloader.board_list[i].selected==true)
        {
            something_selected=true;
            first_type = downloader.board_list[i].type;
        }
    }
    //check if there is at least one board selected
    if (something_selected == false)
    {
        //if not, this is sthe first board you're going to select,
        //so it's ok, you can select it
        return true;
    }

    //check the compatibility of the board that you selected now, with
    //the previous selected ones. all the boards must be of the same type.
    if (wanted_type != first_type)
    {
        return false;
    }
    else
    {
        return true;
    }
    /*
    switch (wanted_type)
    {
        case BOARD_TYPE_DSP:
        case BOARD_TYPE_2DC:
        case BOARD_TYPE_4DC:
        case BOARD_TYPE_BLL:
            if (first_type == BOARD_TYPE_DSP ||
                first_type == BOARD_TYPE_2DC ||
                first_type == BOARD_TYPE_4DC ||
                first_type == BOARD_TYPE_BLL )
            return true;
            else return false;
        break;
        case BOARD_TYPE_PIC :
        case BOARD_TYPE_SKIN :
        case BOARD_TYPE_STRAIN :
        case BOARD_TYPE_MAIS :
            if (first_type == BOARD_TYPE_PIC  ||
                first_type == BOARD_TYPE_STRAIN ||
                first_type == BOARD_TYPE_MAIS ||
                first_type == BOARD_TYPE_SKIN  )
            return true;
            else return false;
        default:
        case BOARD_UNKNOWN:
             return false;
        break;
    }
    */
    return false;
}

//*********************************************************************************
static void fixed_toggled (GtkCellRendererToggle *cell, gchar *path_str, gpointer data)
{
    GtkTreeModel *model = gtk_tree_view_get_model (GTK_TREE_VIEW(treeview));
    GtkTreeIter  iter;
    GtkTreePath *path = gtk_tree_path_new_from_string (path_str);
    gboolean fixed;

    // get toggled iter
    gtk_tree_model_get_iter (model, &iter, path);
    gtk_tree_model_get (model, &iter, COLUMN_SELECTED, &fixed, -1);

    // do something with the value
    fixed ^= 1;

    int* index;
    index = gtk_tree_path_get_indices (path);

    //check if the current selection is compatible with the previous selected boards
    if (validate_selection (downloader.board_list[index[0]].type))
    {
    }
    else
    {
        //impossible to select this board (different types!)
        dialog_message(GTK_MESSAGE_ERROR,"Impossible to select this board!",
                      "Impossible to select a board of a different type \nrespect to the others already selected. \nDeselect them first!");
        return;
    }

    if (index!=NULL && index[0]<downloader.board_list_size)
    {
        downloader.board_list[index[0]].selected=(fixed?true:false);
    }
    else
    {
        printf ("ERR: Something wrong in the selection\n");
    }

    if (calibration_enabled)
    {
        if (validate_calibration ())
        {
            gtk_widget_set_sensitive (calibrate_button, true);
        }
        else
        {
            gtk_widget_set_sensitive (calibrate_button, false);
        }
    }

    // set new value
    gtk_list_store_set (GTK_LIST_STORE (model), &iter, COLUMN_SELECTED, fixed, -1);

    // clean up
    gtk_tree_path_free (path);
}

//*********************************************************************************
static void eeprom_toggled (GtkCellRendererToggle *cell, gchar *path_str, gpointer data)
{
    GtkTreeModel *model = gtk_tree_view_get_model (GTK_TREE_VIEW(treeview));
    GtkTreeIter  iter;
    GtkTreePath *path = gtk_tree_path_new_from_string (path_str);
    gboolean fixed;

    // get toggled iter
    gtk_tree_model_get_iter (model, &iter, path);
    gtk_tree_model_get (model, &iter, COLUMN_EEPROM, &fixed, -1);

    // do something with the value
    fixed ^= 1;

    int* index;
    index = gtk_tree_path_get_indices (path);

    //check if the current selection is compatible with the previous selected boards
/*    if (validate_selection (downloader.board_list[index[0]].type))
    {
    }
    else
    {
        //impossible to select this board (different types!)
        dialog_message(GTK_MESSAGE_ERROR,"Impossible to select this board!",
                      "Impossible to select a board of a different type \nrespect to the others already selected. \nDeselect them first!");
        return;
    }
*/
    if (index!=NULL && index[0]<downloader.board_list_size)
    {
        downloader.board_list[index[0]].eeprom=(fixed?true:false);
    }
    else
    {
        printf ("ERR: Something wrong in the selection\n");
    }

    // set new value
    gtk_list_store_set (GTK_LIST_STORE (model), &iter, COLUMN_EEPROM, fixed, -1);

    // clean up
    gtk_tree_path_free (path);
}
//*********************************************************************************
static void add_columns (GtkTreeView *treeview)
{
    GtkCellRenderer *renderer;
    GtkTreeViewColumn *column;
    GtkTreeModel *model = gtk_tree_view_get_model (treeview);

    // column 1 SELECTED
    renderer = gtk_cell_renderer_toggle_new ();
    g_signal_connect (renderer, "toggled", G_CALLBACK (fixed_toggled), NULL);

    column = gtk_tree_view_column_new_with_attributes ("Selected",
        renderer,
        "active", COLUMN_SELECTED,
        NULL);

    // set this column to a fixed sizing
    gtk_tree_view_column_set_sizing (GTK_TREE_VIEW_COLUMN (column),GTK_TREE_VIEW_COLUMN_FIXED);
    gtk_tree_view_column_set_fixed_width (GTK_TREE_VIEW_COLUMN (column), 70);
    gtk_tree_view_append_column (treeview, column);

    // column 2 PID
    renderer = gtk_cell_renderer_text_new ();
    GTK_CELL_RENDERER_TEXT(renderer)->editable=true;
    GTK_CELL_RENDERER_TEXT(renderer)->editable_set=true;
    renderer->mode=GTK_CELL_RENDERER_MODE_EDITABLE;
    g_signal_connect (renderer, "edited", G_CALLBACK (edited_board_id), NULL);

    column = gtk_tree_view_column_new_with_attributes ("ID",
        renderer,
        "text",
        COLUMN_ID,
        NULL);
    gtk_tree_view_column_set_sizing (GTK_TREE_VIEW_COLUMN (column),GTK_TREE_VIEW_COLUMN_FIXED);
    gtk_tree_view_column_set_fixed_width (GTK_TREE_VIEW_COLUMN (column), 40);
    //gtk_tree_view_column_set_sort_column_id (column, COLUMN_ID);
    gtk_tree_view_append_column (treeview, column);

    // column 3 BOARD TYPE
    renderer = gtk_cell_renderer_text_new ();
    column = gtk_tree_view_column_new_with_attributes ("Type",
        renderer,
        "text",
        COLUMN_TYPE,
        NULL);
    gtk_tree_view_column_set_sizing (GTK_TREE_VIEW_COLUMN (column),GTK_TREE_VIEW_COLUMN_FIXED);
    gtk_tree_view_column_set_fixed_width (GTK_TREE_VIEW_COLUMN (column), 90);
    //gtk_tree_view_column_set_sort_column_id (column, COLUMN_TYPE);
    gtk_tree_view_append_column (treeview, column);

    // column 4 VERSION
    renderer = gtk_cell_renderer_text_new ();
    column = gtk_tree_view_column_new_with_attributes ("Release",
        renderer,
        "text",
        COLUMN_VERSION,
        NULL);
    gtk_tree_view_column_set_sizing (GTK_TREE_VIEW_COLUMN (column),GTK_TREE_VIEW_COLUMN_FIXED);
    gtk_tree_view_column_set_fixed_width (GTK_TREE_VIEW_COLUMN (column), 60);
    //gtk_tree_view_column_set_sort_column_id (column, COLUMN_VERSION);
    gtk_tree_view_append_column (treeview, column);

    // column 5 REVISION
    renderer = gtk_cell_renderer_text_new ();
    column = gtk_tree_view_column_new_with_attributes ("Version",
        renderer,
        "text",
        COLUMN_RELEASE,
        NULL);
    gtk_tree_view_column_set_sizing (GTK_TREE_VIEW_COLUMN (column),GTK_TREE_VIEW_COLUMN_FIXED);
    gtk_tree_view_column_set_fixed_width (GTK_TREE_VIEW_COLUMN (column), 60);
    //gtk_tree_view_column_set_sort_column_id (column, COLUMN_RELEASE);
    gtk_tree_view_append_column (treeview, column);

    // column 5b BUILD
    renderer = gtk_cell_renderer_text_new ();
    column = gtk_tree_view_column_new_with_attributes ("Build",
        renderer,
        "text",
        COLUMN_BUILD,
        NULL);
    gtk_tree_view_column_set_sizing (GTK_TREE_VIEW_COLUMN (column),GTK_TREE_VIEW_COLUMN_FIXED);
    gtk_tree_view_column_set_fixed_width (GTK_TREE_VIEW_COLUMN (column), 70);
    //gtk_tree_view_column_set_sort_column_id (column, COLUMN_RELEASE);
    gtk_tree_view_append_column (treeview, column);

    // column 5c SERIAL
    renderer = gtk_cell_renderer_text_new ();
    column = gtk_tree_view_column_new_with_attributes ("Serial",
        renderer,
        "text",
        COLUMN_SERIAL,
        NULL);
    gtk_tree_view_column_set_sizing (GTK_TREE_VIEW_COLUMN (column),GTK_TREE_VIEW_COLUMN_FIXED);
    gtk_tree_view_column_set_fixed_width (GTK_TREE_VIEW_COLUMN (column), 70);
    //gtk_tree_view_column_set_sort_column_id (column, COLUMN_RELEASE);
    gtk_tree_view_append_column (treeview, column);

    // column 6 STATUS
    renderer = gtk_cell_renderer_text_new ();
    column = gtk_tree_view_column_new_with_attributes ("Status",
        renderer,
        "text",
        COLUMN_STATUS,
        NULL);
    gtk_tree_view_column_set_sizing (GTK_TREE_VIEW_COLUMN (column),GTK_TREE_VIEW_COLUMN_FIXED);
    gtk_tree_view_column_set_fixed_width (GTK_TREE_VIEW_COLUMN (column), 100);
    //gtk_tree_view_column_set_sort_column_id (column, COLUMN_STATUS);
    gtk_tree_view_append_column (treeview, column);

    // column 7 ADDITIONAL INFO
    renderer = gtk_cell_renderer_text_new ();
    GTK_CELL_RENDERER_TEXT(renderer)->editable=true;
    GTK_CELL_RENDERER_TEXT(renderer)->editable_set=true;
    renderer->mode=GTK_CELL_RENDERER_MODE_EDITABLE;
    g_signal_connect (renderer, "edited", G_CALLBACK (edited_additional_info), NULL);

    column = gtk_tree_view_column_new_with_attributes ("Additional Info",
        renderer,
        "text",
        COLUMN_ADD_INFO,
        NULL);
    gtk_tree_view_column_set_sizing (GTK_TREE_VIEW_COLUMN (column),GTK_TREE_VIEW_COLUMN_FIXED);
    gtk_tree_view_column_set_fixed_width (GTK_TREE_VIEW_COLUMN (column), 200);
    //gtk_tree_view_column_set_sort_column_id (column, COLUMN_ADD_INFO);
    gtk_tree_view_append_column (treeview, column);

    // column 8 EEPROM
    renderer = gtk_cell_renderer_toggle_new ();
    g_signal_connect (renderer, "toggled", G_CALLBACK (eeprom_toggled), NULL);

    column = gtk_tree_view_column_new_with_attributes ("EEPROM",
        renderer,
        "active", COLUMN_EEPROM,
        NULL);

    // set this column to a fixed sizing
    gtk_tree_view_column_set_sizing (GTK_TREE_VIEW_COLUMN (column),GTK_TREE_VIEW_COLUMN_FIXED);
    gtk_tree_view_column_set_fixed_width (GTK_TREE_VIEW_COLUMN (column), 40);
    gtk_tree_view_append_column (treeview, column);

}

//*********************************************************************************
// This callback exits from the gtk_main() main loop when the main window is closed
static void destroy_main (GtkWindow *window,    gpointer   user_data)
{
   gtk_widget_destroy (GTK_WIDGET(window));
   gtk_main_quit ();
}

void fatal_error(int err)
{
    switch (err)
    {
        case INVALID_CMD_STRING:
            printf("Error parsing the command line. The correct format is:\n");
            printf("canLoader --canDeviceType t --canDeviceNum x --boardId y --firmware myFirmware.out.S\n");
            printf("canLoader --canDeviceType EMS --canDeviceNum 1|2 --boardId y --firmware myFirmware.out.S --boardIPAddr aaa.aaa.aaa.aaa\n");
            ::exit(err);
        break;
        case INVALID_PARAM_CANTYPE:
            printf("ERROR: invalid --canDeviceType parameter \n");
            printf("must be 'ecan' or 'pcan' or 'cfw2' or 'socketcan'\n");
            ::exit(err);
        break;
        case INVALID_PARAM_CANNUM:
            printf("ERROR: invalid --canDeviceNum parameter \n");
            printf("must be between 0 and 3\n");
            ::exit(err);
        break;
        case INVALID_PARAM_BOARDID:
            printf("ERROR: invalid --boardId parameter \n");
            printf("must be between 0 and 15\n");
            ::exit(err);
        break;
        case INVALID_PARAM_FILE:
            printf("ERROR: invalid --firmware parameter \n");
            printf("file not found\n");
            ::exit(err);
        break;
        case ERR_NO_BOARDS_FOUND:
            printf("ERROR: no boards found \n");
            printf("check canbus cable, power supply connection etc.\n");
            ::exit(err);
        break;
        case ERR_BOARD_ID_NOT_FOUND:
            printf("ERROR: the specified board is not available \n");
            ::exit(err);
        break;
        case ERR_NO_NETWORK_INTERFACE:
            printf("ERROR: could not find network interface\n");
            ::exit(err);
        case ERR_UNKNOWN:
        default:
            printf("Unknown error\n");
            ::exit(ERR_UNKNOWN);
        break;

    }

}
//*********************************************************************************
// Entry point for the GTK application
int myMain( int   argc, char *argv[] )
{    /*  //for debug only
    downloader.board_list= new sBoard[1];
    downloader.board_list[0].pid     = 10;
    downloader.board_list[0].type    = BOARD_TYPE_BLL;
    downloader.board_list[0].version = 11;
    downloader.board_list[0].release = 1;
    downloader.board_list[0].status  = BOARD_RUNNING;
    downloader.board_list[0].selected  = false;
    strcpy(downloader.board_list[0].add_info , "can flasher default");
    printf("%d\n");gtk_widget_set_sensitive (treeview, true);
    downloader.board_list_size=1;
    */

    networkType="empty";

    #ifdef USE_ICUB_MOD
    yarp::dev::DriverCollection dev;
    #endif

    if   (argc==2 && strcmp(argv[1],"--calib")==0)
    {
         calibration_enabled=true;
    }
    //printf("argc = %d\n",argc);
    else if (argc!=1)
    {
        prompt_version=true;
        printf("Initializing prompt version of canLoader...\n");
        if      (argc==2 && strcmp(argv[1],"--help")==0)
        {
                printf("CANLOADER APPLICATION V2.9\n");
                printf("Syntax:\n");
                printf("1) to execute the GUI version of the canLoader:\n");
                printf("./canLoader \n");
                printf("2) to execute the command line version of the canLoader:\n");
                printf("./canLoader --canDeviceType <t> --canDeviceNum <x> --boardId <y> --firmware myFirmware.out.S\n");
                printf("./canLoader --canDeviceType EMS --canDeviceNum 1|2 --boardId <y> --firmware myFirmware.out.S --boardIPAddr <aaa.aaa.aaa.aaa>\n");
                printf("parameter <t> is the name of the CAN bus driver. It can be 'ecan' or 'pcan' or 'cfw2can' or 'socketcan'\n");
                printf("parameter <x> is the number of the CAN bus (0-9)\n");
                printf("parameter <y> is the CAN address of the board (0-14)\n");
                printf("parameter <aaa.aaa.aaa.aaa> IP address of the board (EMS ethernet boards only)\n");
                ::exit(0);
        }
        if        (argc==9 || argc==11)
        {
                //printf("canLoader --canDeviceType t --canDeviceNum x --boardId y --firmware myFirmware.out.S\n");
                if (strcmp(argv[1],"--canDeviceType")!=0)       fatal_error(INVALID_CMD_STRING);
                if (strcmp(argv[3],"--canDeviceNum")!=0)        fatal_error(INVALID_CMD_STRING);
                if (strcmp(argv[5],"--boardId")!=0)                fatal_error(INVALID_CMD_STRING);
                if (strcmp(argv[7],"--firmware")!=0 &&
                    strcmp(argv[7],"--calibration")!=0 &&
                    strcmp(argv[7],"--firmwareANDeeprom")!=0)    fatal_error(INVALID_CMD_STRING);

                int param_board_id=0;
                std::string param_filename = "empty";
                int temp_val=-1;

                if (strcmp(argv[2],"ecan") !=0 &&
                    strcmp(argv[2],"pcan") !=0 &&
                    strcmp(argv[2],"cfw2can")!=0 &&
                    strcmp(argv[2],"socketcan")!=0 &&
                    strcmp(argv[2],"EMS")!=0)
                    {
                        fatal_error(INVALID_PARAM_CANTYPE);
                    }
                else
                    {
                        networkType=argv[2];
                    }

                if (networkType=="EMS")
                {
                    if (argc!=11 || strcmp(argv[9],"--boardIPAddr")) fatal_error(INVALID_CMD_STRING);

                    if (!compile_ip_addresses(argv[10]))
                    {
                        fatal_error(ERR_NO_NETWORK_INTERFACE);
                    }
                }

                temp_val=atoi(argv[4]);
                if (temp_val<0 || temp_val>9)
                    {
                        fatal_error(INVALID_PARAM_CANNUM);
                    }
                else
                    {
                        canID=networkId=temp_val;
                    }

                temp_val=atoi(argv[6]);
                if (temp_val<0 || temp_val>15)
                    {
                        fatal_error(INVALID_PARAM_BOARDID);
                    }
                else
                    {
                        param_board_id=temp_val;
                    }

                param_filename=argv[8];
                std::fstream filestr;
                filestr.open ( param_filename.c_str(), std::fstream::in);
                if (!filestr.is_open())
                    {
                        //file not exists
                        fatal_error(INVALID_PARAM_FILE);
                    }
                else
                    {
                        filestr.close();
                    }
                printf("Selecting canDeviceType %s canDeviceNum %d, boardId %d, firmware %s\n", networkType.c_str(), networkId, param_board_id, param_filename.c_str());

                //eeprom check
                bool use_eeprom=false;
                if (strcmp(argv[7],"--firmwareANDeeprom")==0)
                {
                    printf("EEprom flag is active \n");
                    use_eeprom=true;
                }

                start_end_click (NULL,    NULL);
                if (downloader.board_list_size==0)
                    {
                        fatal_error(ERR_NO_BOARDS_FOUND);
                    }

                int i;
                bool one_selected=false;
                for (i = 0; i < downloader.board_list_size; i++)
                    {
                        if (downloader.board_list[i].pid==param_board_id)
                            {
                                downloader.board_list[i].selected=true;
                                one_selected=true;
                                if (use_eeprom==true) downloader.board_list[i].eeprom=true;
                            }
                    }
                if (one_selected==false)
                    {
                        fatal_error(ERR_BOARD_ID_NOT_FOUND);
                    }

                int ret=download_click(NULL, &param_filename);
                if (ret==ALL_OK)
                    printf("Program terminated successfully!\n");
                else
                    printf("Program terminated, DOWNLOAD FAILED!\n");
                ::exit(ret);
        }
        if        (argc!=9)
        {
          //      fatal_error(INVALID_CMD_STRING);
        }
    }
    else
    {
        printf("Initializing GUI version of canloader\n");

    }
    GtkTreeModel *model;
    gtk_init (&argc, &argv);

    //create the main window, and sets the callback destroy_main() to quit
    //the application when the main window is closed
    window = gtk_window_new (GTK_WINDOW_TOPLEVEL);
    gtk_window_set_title (GTK_WINDOW (window), "CAN Flasher V2.9");
    g_signal_connect (window, "destroy",G_CALLBACK (destroy_main), &window);

    gtk_container_set_border_width (GTK_CONTAINER (window), 8);

    //Creation of main_vbox the container for every other widget
    main_vbox = gtk_vbox_new (FALSE, 0);
    gtk_container_add (GTK_CONTAINER (window), main_vbox);

    //creation of the top_hbox
    top_hbox = gtk_hbox_new (FALSE, 0);
    gtk_container_set_border_width (GTK_CONTAINER (top_hbox), 10);
    gtk_container_add (GTK_CONTAINER (main_vbox), top_hbox);

    //widget in the top frame
    //deviceNameEntry=gtk_entry_new();
    //gtk_entry_set_editable(GTK_ENTRY(deviceNameEntry),true);
    //gtk_entry_set_text(GTK_ENTRY(deviceNameEntry),networkType.c_str());
    inv1 = gtk_fixed_new ();
    gtk_container_add                (GTK_CONTAINER (top_hbox), inv1);

    start_end_button = gtk_button_new_with_mnemonic ("Connect");

    gtk_fixed_put                    (GTK_FIXED(inv1), start_end_button, 0, 0);
    gtk_widget_set_size_request     (start_end_button, 80, 30);
    g_signal_connect                (start_end_button, "clicked", G_CALLBACK (start_end_click), NULL);

    //net type selection
    model = create_netType_model ();
    combo_netType = gtk_combo_box_new_with_model (model);
    g_object_unref (model);
    GtkCellRenderer* renderer =         gtk_cell_renderer_text_new ();
    gtk_cell_layout_pack_start        (GTK_CELL_LAYOUT (combo_netType), renderer, TRUE);
    gtk_cell_layout_set_attributes  (GTK_CELL_LAYOUT (combo_netType), renderer,"text", 0, NULL);
    gtk_widget_set_size_request     (combo_netType, 100, 30);
    gtk_combo_box_set_active        (GTK_COMBO_BOX (combo_netType), 0);
    g_signal_connect                (combo_netType, "changed", G_CALLBACK (combo_nettype_changed), NULL);
    gtk_fixed_put                    (GTK_FIXED(inv1), combo_netType ,250, 0);


    //can bus id selection
    model = create_canId_model ();
    combo_canId = gtk_combo_box_new_with_model (model);
    g_object_unref (model);
    gtk_cell_layout_pack_start        (GTK_CELL_LAYOUT (combo_canId), renderer, TRUE);
    gtk_cell_layout_set_attributes  (GTK_CELL_LAYOUT (combo_canId), renderer,"text", 0, NULL);
    gtk_widget_set_size_request     (combo_canId, 100, 30);
    gtk_combo_box_set_active        (GTK_COMBO_BOX (combo_canId), 0);
    g_signal_connect                (combo_canId, "changed", G_CALLBACK (combo_canid_changed), NULL);
    gtk_fixed_put                    (GTK_FIXED(inv1), combo_canId ,400, 0);


    //net id selection
    model = create_net_model ();
    combo_netId = gtk_combo_box_new_with_model (model);
    g_object_unref (model);
    gtk_cell_layout_pack_start      (GTK_CELL_LAYOUT (combo_netId), renderer, TRUE);
    gtk_cell_layout_set_attributes  (GTK_CELL_LAYOUT (combo_netId), renderer,"text", 0, NULL);
    gtk_widget_set_size_request     (combo_netId, 100, 30);
    gtk_combo_box_set_active        (GTK_COMBO_BOX (combo_netId), 0);
    g_signal_connect                (combo_netId, "changed", G_CALLBACK (combo_netid_changed), NULL);
    gtk_fixed_put                   (GTK_FIXED(inv1), combo_netId ,100, 0);


    //ip address selection
    box_ipAddr = gtk_entry_new();
    gtk_widget_set_size_request     (box_ipAddr, 100, 20);
    gtk_widget_set_sensitive        (box_ipAddr, false);
    gtk_entry_set_text              (GTK_ENTRY(box_ipAddr), "10.0.1.1");
    gtk_fixed_put                   (GTK_FIXED(inv1), box_ipAddr ,550, 5);

    combo_nettype_changed            (GTK_COMBO_BOX (combo_netType),0);
    combo_canid_changed              (GTK_COMBO_BOX (combo_canId),0);
    combo_netid_changed              (GTK_COMBO_BOX (combo_netId) ,0);

    ///////////////////////////////

//    gtk_container_add (GTK_CONTAINER (top_hbox), deviceNameEntry);

    //Creation of the bottom frame
    bottom_hbox = gtk_hbox_new (FALSE, 8);
    gtk_container_set_border_width (GTK_CONTAINER (bottom_hbox), 10);
    gtk_container_add (GTK_CONTAINER (main_vbox), bottom_hbox);

    //In the bottom frame there is:
    //1) the list of the cards
    sw = gtk_scrolled_window_new (NULL, NULL);
    gtk_scrolled_window_set_shadow_type (GTK_SCROLLED_WINDOW (sw), GTK_SHADOW_ETCHED_IN);
    gtk_scrolled_window_set_policy (GTK_SCROLLED_WINDOW (sw), GTK_POLICY_NEVER, GTK_POLICY_AUTOMATIC);
    gtk_box_pack_start (GTK_BOX (bottom_hbox), sw, TRUE, TRUE, 0);

    // A Label
    // label = gtk_label_new ("Connected Board List");
    // gtk_box_pack_start (GTK_BOX (main_vbox), label, FALSE, FALSE, 0);

    {
        //List of the cards
        //create tree model
        model = refresh_board_list_model ();

        //create tree view
        treeview = gtk_tree_view_new_with_model (model);
        gtk_tree_view_set_rules_hint (GTK_TREE_VIEW (treeview), TRUE);
        gtk_tree_view_set_search_column (GTK_TREE_VIEW (treeview),COLUMN_ID);

        g_object_unref (model);

        gtk_container_add (GTK_CONTAINER (sw), treeview);

        // add columns to the tree view
        add_columns (GTK_TREE_VIEW (treeview));
    }

    //2) A panel in the right
    panel_hbox = gtk_vbox_new (FALSE, 8);
    gtk_container_set_border_width (GTK_CONTAINER (panel_hbox), 10);
    gtk_container_add (GTK_CONTAINER (bottom_hbox), panel_hbox);

    {
        //Button 1 in the panel
        button1 = gtk_button_new_with_mnemonic ("Select All");
        gtk_container_add (GTK_CONTAINER (panel_hbox ), button1);
        g_signal_connect (button1, "clicked", G_CALLBACK (select_all),NULL);
        gtk_widget_set_size_request     (button1, 130, 30);

        //Button 2 in the panel
        button2 = gtk_button_new_with_mnemonic ("Deselect All");
        gtk_container_add (GTK_CONTAINER (panel_hbox ), button2);
        g_signal_connect (button2, "clicked", G_CALLBACK (deselect_all),NULL);
        gtk_widget_set_size_request     (button2, 130, 30);

        //Download button in the panel
        download_button = gtk_button_new_with_mnemonic ("Start Download");
        gtk_container_add (GTK_CONTAINER (panel_hbox ), download_button);
        g_signal_connect (download_button, "clicked", G_CALLBACK (download_click),NULL);
        gtk_widget_set_size_request     (download_button, 130, 30);

        //find default path
        std::fstream filestr;
        char path[256];
        char calib_string[256];
        filestr.open ("config.txt", std::fstream::in);
        if (filestr.is_open())
        {
            filestr.getline (path,255);
            filestr.getline (calib_string,255);
            filestr.close();
            filestr.clear();
        }

        if (strcmp(calib_string,"calib")==0) calibration_enabled=true;
        //calibrate button in the panel
        if (calibration_enabled==true)
        {
            calibrate_button = gtk_button_new_with_mnemonic ("Calibrate");
            gtk_container_add (GTK_CONTAINER (panel_hbox ), calibrate_button);
            g_signal_connect (calibrate_button, "clicked", G_CALLBACK (calibrate_click),NULL);
            gtk_widget_set_size_request     (calibrate_button, 130, 30);
        }

        //file chooser
        picker = gtk_file_chooser_button_new ("Pick a File", GTK_FILE_CHOOSER_ACTION_OPEN);

        gtk_box_pack_start (GTK_BOX (panel_hbox), picker, TRUE, TRUE, 0);
        g_signal_connect (picker, "selection-changed", G_CALLBACK (choose_file), NULL);
        gtk_widget_set_size_request     (picker, 130, 30);
        gtk_file_chooser_set_filename (GTK_FILE_CHOOSER(picker), path);

        //progress bar
        progress_bar=gtk_progress_bar_new ();
        gtk_container_add (GTK_CONTAINER (panel_hbox ), progress_bar);
        gtk_widget_set_size_request     (progress_bar, 130, 25);

    }

    // finish & show
    not_connected_status();
    //    connected_status();
    gtk_window_set_default_size (GTK_WINDOW (window), 480, 250);
    gtk_window_set_resizable (GTK_WINDOW (window), false);

    if (!GTK_WIDGET_VISIBLE (window))
        gtk_widget_show_all (window);
    else
    {
        gtk_widget_destroy (window);
        window = NULL;
    }

    gtk_main ();
    return 0;
}

int main(int argc, char* argv[])
{
    YARP_REGISTER_DEVICES(icubmod)

    return myMain(argc, argv);
}

/*
#ifdef WIN32
#include <windows.h>
// win32 non-console applications define WinMain as the
// entry point for the linker
int WINAPI WinMain(HINSTANCE hInstance,
                   HINSTANCE hPrevInstance,
                   LPSTR lpCmdLine,
                   int nCmdShow)
{
    AllocConsole();
    HANDLE handle_out = GetStdHandle(STD_OUTPUT_HANDLE);
    int hCrt = _open_osfhandle((long) handle_out, _O_TEXT);
    FILE* hf_out = _fdopen(hCrt, "w");
    setvbuf(hf_out, NULL, _IONBF, 1);
    HANDLE handle_in = GetStdHandle(STD_INPUT_HANDLE);
    hCrt = _open_osfhandle((long) handle_in, _O_TEXT);
    FILE* hf_in = _fdopen(hCrt, "r");
    setvbuf(hf_in, NULL, _IONBF, 128);
    *stdin  = *hf_in;
    *stdout = *hf_out;

    return myMain (__argc, __argv);

}
#else
int main(int argc, char* argv[])
{
    return myMain(argc, argv);
}
#endif
*/
