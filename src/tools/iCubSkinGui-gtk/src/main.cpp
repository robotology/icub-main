// -*- mode:C++; tab-width:4; c-basic-offset:4; indent-tabs-mode:nil -*-

/*
 * Copyright (C) 2009 RobotCub Consortium
 * Author: Alessandro Scalzo alessandro.scalzo@iit.it
 * CopyPolicy: Released under the terms of the GNU GPL v2.0.
 *
 */

/**
*
@ingroup icub_guis
\defgroup icub_iCubSkinGui iCubSkinGui

A gui to display the output of fingertip/skin tactile sensors.

\section intro_sec Description
The application is used to graphically display the output of the iCub fingertip/skin tactile sensors.
This application can be used in two different modalities, CAN mode and YARP mode.
If used in CAN mode, the application reads sensor data directly from the CAN bus.

If used in "YARP" mode,the application requires a yarp port connection to the iCubInterface output.

\section lib_sec Libraries
YARP libraries.
GTK libraries.

\section parameters_sec Parameters

Usage:

iCubSkinGui <--from filename.ini> <--useCan>

You can use the --from parameter (optional) to specify a .ini configuration file.

If no configuration file is specified, then $ICUB_ROOT/app/iCubSkinDemo/lefthand.ini is used.

You can use the --useCan parameter (optional) to ask the application to read sensor data directly from the CAN bus
(the CAN parameters must be specified in the configuration file). Otherwise the application opens an input
yarp ports and waits for a yarp connection with a stream of sensory data.

\section portsa_sec Ports Accessed
None

\section portsc_sec Ports Created
This application can be used in two different modalities, CAN mode and YARP mode.

If used in CAN mode, this application does not create any input port, and the data are directly obtained from the CAN bus.

If used in YARP mode, this application creates the port:

/skinGui/<robotPart>:i

where <robotPart> correspondes to the value
of the parameter robotPart contained in the .ini configuration file.

For example, if $ICUB_ROOT/app/iCubSkinDemo/lefthand.ini
is used, the module creates the port /skinGui/left_hand:i. The port must be afterwards
connected to the output port corresponding to the skin output in iCubInterface.

Examples:

yarp connect /icub/skin/lefthand /skinGui/left_hand:i

yarp connect /icub/skin/righthand /skinGui/right_hand:i


\section in_files_sec Input Data Files
No input files are required by this application.

\section out_data_sec Output Data Files
No output files are generated by this application.

\section conf_file_sec Configuration Files
The application uses configuration files (e.g. lefthand.ini) located in $ICUB_ROOT/app/iCubSkinDemo.
You can select the configuration file used by the application using:

--from <filename>.

If the --from parameter is not specified, $ICUB_ROOT/app/iCubSkinDemo/lefthand.ini is used as default.

\section tested_os_sec Tested OS
Linux and Windows.

\section example_sec Example Instantiation of the Module

iCubSkinGui

iCubSkinGui --from lefthand.ini

iCubSkinGui --from righthand.ini

iCubSkinGui --from lefthand.ini --useCan

iCubSkinGui --from righthand.ini --useCan

\author Alessandro Scalzo, Lorenzo Natale, Marco Randazzo

Copyright (C) 2009 RobotCub Consortium

CopyPolicy: Released under the terms of the GNU GPL v2.0.

This file can be edited at /src/gui/iCubSkinGui/src/main.cpp.
**/

#include <mutex>
#include <memory.h>

#include <yarp/os/all.h>
#include "include/SkinMeshThreadCan.h"
#include "include/SkinMeshThreadPort.h"

#include <gtk/gtk.h>
#include <gdk/gdk.h>
#include <glib.h>

using namespace yarp::os;

static GtkWidget *gpDrawingArea=NULL;
static SkinMeshThreadCan  *gpSkinMeshThreadCan=NULL;
static SkinMeshThreadPort *gpSkinMeshThreadPort=NULL;
static std::mutex gMutex;
static int gbRunning=TRUE;
static int gWidth=0,gHeight=0,gRowStride=0,gImageSize=0,gMapSize=0,gImageArea=0;
static int gXpos=32,gYpos=32;
static double *gpActivationMap=NULL;
static guchar *gpImageBuff=NULL;
static guint gTimer;
enum   TheadTypeEnum {TYPE_CAN, TYPE_PORT};
static int TheadType = TYPE_PORT;

static int timer_handler(gpointer dummy)
{
    gtk_widget_queue_draw(gpDrawingArea);

    return 1;
}

static gint paint(GtkWidget *pWidget,GdkEventExpose *pEvent,gpointer pData)
{
    gint width=0,height=0;
    gdk_drawable_get_size(pWidget->window,&width,&height);

    //gint width =gpDrawingArea->allocation.width;
    //gint height=gpDrawingArea->allocation.height;

    static bool bDrawing=false;

    if (!gbRunning) return FALSE;

    if (bDrawing) return TRUE;

    std::lock_guard<std::mutex> lck(gMutex);

    bDrawing=true;

    if (width!=gWidth || height!=gHeight)
    {
        gWidth=width;
        gHeight=height;

        gRowStride=3*gWidth;
        gImageSize=gRowStride*gHeight;
        gImageArea=gWidth*gHeight;
        gMapSize=gWidth*gHeight*sizeof(double);

        if (gpActivationMap) delete [] gpActivationMap;
        if (gpImageBuff) delete [] gpImageBuff;
        gpActivationMap=new double[gImageArea];
        gpImageBuff=new guchar[gImageSize];

        if      (TheadType == TYPE_CAN && gpSkinMeshThreadCan  && gWidth>=180 && gHeight>=180)
                 gpSkinMeshThreadCan->resize(gWidth,gHeight);
        else if (TheadType == TYPE_PORT && gpSkinMeshThreadPort && gWidth>=180 && gHeight>=180)
                 gpSkinMeshThreadPort->resize(gWidth,gHeight);
    }

    if (TheadType == TYPE_CAN && gpSkinMeshThreadCan)
    {
        //memset(gpActivationMap,0,gMapSize);
        memset(gpImageBuff,0,gImageSize);

        if (gWidth>=180 && gHeight>=180)
        {
            //gpSkinMeshThreadCan->eval(gpActivationMap);
            gpSkinMeshThreadCan->eval(gpImageBuff);

            /*
            for (int i=0; i<gImageArea; ++i)
            {
                gpImageBuff[i*3]=gpActivationMap[i]<255.0?guchar(gpActivationMap[i]):255;
            }
            */

            gpSkinMeshThreadCan->draw(gpImageBuff);
        }

        gdk_draw_rgb_image(pWidget->window,
                           pWidget->style->black_gc,
                           pEvent->area.x,pEvent->area.y,
                           pEvent->area.width,pEvent->area.height,
                           GDK_RGB_DITHER_NONE,
                           gpImageBuff,
                           gRowStride);
    }
    else if (TheadType == TYPE_PORT && gpSkinMeshThreadPort)
    {
        //memset(gpActivationMap,0,gMapSize);
        memset(gpImageBuff,0,gImageSize);

        if (gWidth>=180 && gHeight>=180)
        {
            //gpSkinMeshThreadPort->eval(gpActivationMap);
            gpSkinMeshThreadPort->eval(gpImageBuff);

            /*
            for (int i=0; i<gImageArea; ++i)
            {
                gpImageBuff[i*3]=gpActivationMap[i]<255.0?guchar(gpActivationMap[i]):255;
            }
            */

            gpSkinMeshThreadPort->draw(gpImageBuff);
        }

        gdk_draw_rgb_image(pWidget->window,
                           pWidget->style->black_gc,
                           pEvent->area.x,pEvent->area.y,
                           pEvent->area.width,pEvent->area.height,
                           GDK_RGB_DITHER_NONE,
                           gpImageBuff,
                           gRowStride);
    }

    bDrawing=false;

    return TRUE;
}

void clean_exit()
{
    std::lock_guard<std::mutex> lck(gMutex);
    gbRunning=FALSE;
    g_source_remove(gTimer);
    gtk_main_quit();
}

int main(int argc, char *argv[])
{
    Network yarp;

    yarp::os::ResourceFinder rf;
    rf.setVerbose();
    rf.setDefaultContext("skinGui/skinGui");
    rf.setDefaultConfigFile("left_hand.ini");
    rf.configure(argc,argv);

    gWidth =rf.find("width" ).asInt();
    gHeight=rf.find("height").asInt();
    if (rf.check("xpos")) gXpos=rf.find("xpos").asInt();
    if (rf.check("ypos")) gYpos=rf.find("ypos").asInt();

    bool useCan = rf.check("useCan");
    if (useCan==true)
    {
        printf("CAN version: Reading data directly from CAN\n");
        TheadType=TYPE_CAN;
    }
    else
    {
        printf("YARP version: reading data from a Yarp port\n");
        TheadType=TYPE_PORT;
    }

    gRowStride=3*gWidth;
    gImageSize=gRowStride*gHeight;
    gMapSize=gWidth*gHeight*sizeof(double);
    gImageArea=gWidth*gHeight;

    gpActivationMap=new double[gImageArea];
    gpImageBuff=new guchar[gImageSize];

#if !GLIB_CHECK_VERSION(2, 32, 0)
    // since Glib 2.32 g_thread_init is deprecated
    g_thread_init (NULL);
#endif

    gdk_threads_init ();
    gdk_threads_enter ();
    gtk_init(&argc,&argv);

    GtkWidget *pMainWindow=gtk_window_new(GTK_WINDOW_TOPLEVEL);
    std::string window_title="SkinGui (part: ";
    window_title.append(rf.find("robotPart").asString());
    window_title.append(")");
    gtk_window_set_title(GTK_WINDOW(pMainWindow),window_title.c_str());
    gtk_window_set_resizable(GTK_WINDOW(pMainWindow),TRUE);
    gtk_window_set_default_size(GTK_WINDOW(pMainWindow),gWidth,gHeight);
    gtk_window_resize(GTK_WINDOW(pMainWindow),gWidth,gHeight);

    GtkWidget *pBox=gtk_vbox_new(FALSE,0); // parameters (gboolean homogeneous_space, gint spacing);
    gtk_container_add(GTK_CONTAINER(pMainWindow),pBox);

    gpDrawingArea=gtk_drawing_area_new();
    gtk_box_pack_start(GTK_BOX(pBox),gpDrawingArea,TRUE,TRUE,0);

    gtk_signal_connect(GTK_OBJECT(pMainWindow),"destroy",GTK_SIGNAL_FUNC(clean_exit),NULL);
    g_signal_connect(gpDrawingArea,"expose_event",G_CALLBACK(paint),NULL);

    gTimer=g_timeout_add(50,timer_handler,NULL);

    gtk_widget_show_all(pMainWindow);
    gtk_window_move(GTK_WINDOW(pMainWindow),gXpos,gYpos);

    if (TheadType==TYPE_CAN)
    {
        gpSkinMeshThreadCan=new SkinMeshThreadCan(rf,50);
        gpSkinMeshThreadCan->start();

        gtk_main();
        gdk_threads_leave();

        //gtk_widget_destroy(mainWindow);

        gpSkinMeshThreadCan->stop();
        delete gpSkinMeshThreadCan;
    }
    else if (TheadType==TYPE_PORT)
    {
        gpSkinMeshThreadPort=new SkinMeshThreadPort(rf,50);
        gpSkinMeshThreadPort->start();

        gtk_main();
        gdk_threads_leave();

        //gtk_widget_destroy(mainWindow);

        gpSkinMeshThreadPort->stop();
        delete gpSkinMeshThreadPort;
    }

    if (gpActivationMap) delete [] gpActivationMap;
    if (gpImageBuff) delete [] gpImageBuff;
}
