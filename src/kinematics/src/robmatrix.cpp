// Class automatically generated by Dev-C++ New Class wizard
#include <stdio.h>
#include <math.h>

#include <iCub/kinematics/robmatrix.h> // class's header file

// note by rasm (27/Feb/2006):
// Visual C++ 98 needs iostream.h to be included for the next line to work
#include <iostream> // for namespace

using namespace std;

// class constructor
RobMatrix::RobMatrix()
{
    M[0][0]=1;    M[0][1]=0;    M[0][2]=0;    M[0][3]=0;
    M[1][0]=0;    M[1][1]=1;    M[1][2]=0;    M[1][3]=0;
    M[2][0]=0;    M[2][1]=0;    M[2][2]=1;    M[2][3]=0;
    M[3][0]=0;    M[3][1]=0;    M[3][2]=0;    M[3][3]=1;                      
	// insert your code here
}

RobMatrix::RobMatrix( int val )
{
    M[0][0]=0;    M[0][1]=0;    M[0][2]=0;    M[0][3]=0;
    M[1][0]=0;    M[1][1]=0;    M[1][2]=0;    M[1][3]=0;
    M[2][0]=0;    M[2][1]=0;    M[2][2]=0;    M[2][3]=0;
    M[3][0]=0;    M[3][1]=0;    M[3][2]=0;    M[3][3]=val;
	// insert your code here
}

// class destructor
RobMatrix::~RobMatrix()
{
	// insert your code here
}

/*********************************************************************
*
*
*
*
*
***********************************************************************/
RobMatrix::RobMatrix(double x, double y, double z)
{
    M[0][0]=1;    M[0][1]=0;    M[0][2]=0;    M[0][3]=x;
    M[1][0]=0;    M[1][1]=1;    M[1][2]=0;    M[1][3]=y;
    M[2][0]=0;    M[2][1]=0;    M[2][2]=1;    M[2][3]=z;
    M[3][0]=0;    M[3][1]=0;    M[3][2]=0;    M[3][3]=1;
}

RobMatrix::RobMatrix(double x, double y, double z, int val)
{

    M[0][0]=1;    M[0][1]=0;    M[0][2]=0;    M[0][3]=x;
    M[1][0]=0;    M[1][1]=1;    M[1][2]=0;    M[1][3]=y;
    M[2][0]=0;    M[2][1]=0;    M[2][2]=1;    M[2][3]=z;
    M[3][0]=0;    M[3][1]=0;    M[3][2]=0;    M[3][3]=val;
}
/*********************************************************************
*
*
*
*
*
***********************************************************************/
RobMatrix::RobMatrix(double alpha, double a, double ofth, double d)
{
double sal, cal;
    
    this->a=a;
    this->alpha=alpha;
    this->d=d;
    this->ofth=ofth;
    
    sal = sin(alpha);
    cal = cos(alpha);
    
    M[0][0]=1;   M[0][1]=0;   M[0][2]=0;    M[0][3]=a;
    M[1][0]=cal; M[1][1]=cal; M[1][2]=-sal; M[1][3]=-sal*d;
    M[2][0]=sal; M[2][1]=sal; M[2][2]=cal;  M[2][3]=cal*d;
    M[3][0]=0;   M[3][1]=0;   M[3][2]=0;    M[3][3]=1;

}


/*

T =
[         cos(th),        -sin(th),               0,               a]
[ sin(th)*cos(al), cos(th)*cos(al),        -sin(al),      -sin(al)*d]
[ sin(th)*sin(al), cos(th)*sin(al),         cos(al),       cos(al)*d]
[               0,               0,               0,               1]
*/

/*********************************************************************
*
*
*
*
*
***********************************************************************/
RobMatrix RobMatrix::V(double th)
{
double sal, cal, sth, cth;
    
    sal = sin(alpha);
    cal = cos(alpha);
    sth = sin(th+ofth);
    cth = cos(th+ofth);
/*
[         cos(th),        -sin(th),               0,               a]
[ sin(th)*cos(al), cos(th)*cos(al),        -sin(al),      -sin(al)*d]
[ sin(th)*sin(al), cos(th)*sin(al),         cos(al),       cos(al)*d]
[               0,               0,               0,               1]
*/
    
    M[0][0]=cth;     M[0][1]=-sth;
    M[1][0]=sth*cal; M[1][1]=cth*cal;
    M[2][0]=sth*sal; M[2][1]=cth*sal;
    
    return (*this);
}

/*********************************************************************
*
*
*
*
*
***********************************************************************/
RobMatrix RobMatrix::Inv(double th)
{
    return Inv( alpha, a, d, ofth+th);
}

/*********************************************************************
*
*
*
*
*
***********************************************************************/
RobMatrix RobMatrix::Inv(double alpha, double a, double d, double th)
{
    RobMatrix IM;
    double sal, cal, sth, cth;
    
    sal = sin(alpha);
    cal = cos(alpha);
    sth = sin(th+ofth);
    cth = cos(th+ofth);
    
    IM.M[0][0]=cth;  IM.M[0][1]=sth*cal; IM.M[0][2]=sth*sal; IM.M[0][3]=-cth*a;
    IM.M[1][0]=-sth; IM.M[1][1]=cth*cal; IM.M[1][2]=cth*sal; IM.M[1][3]=sth*a;
    IM.M[2][0]=0;    IM.M[2][1]=-sal;    IM.M[2][2]=cal;     IM.M[2][3]=-sal*sal*d-cal*cal*d;
    IM.M[3][0]=0;    IM.M[3][1]=0;       IM.M[3][2]=0;       IM.M[3][3]=1;

    return IM;
}
/*
Tinv =
[                  cos(th),          sin(th)*cos(al),          sin(th)*sin(al),               -cos(th)*a]
[                 -sin(th),          cos(th)*cos(al),          cos(th)*sin(al),                sin(th)*a]
[                        0,                 -sin(al),                  cos(al), -sin(al)^2*d-cos(al)^2*d]
[                        0,                        0,                        0,                        1]
*/

/*********************************************************************
*
*
*
*
*
***********************************************************************/
RobMatrix RobMatrix::operator*(const RobMatrix &param)
{
 RobMatrix IM;
 
 for(int cntl=0;cntl<4;cntl++)
  for(int cntc=0;cntc<4;cntc++)
  {
   IM.M[cntl][cntc]=0;
   for(int cnto=0;cnto<4;cnto++)
    IM.M[cntl][cntc]+=M[cntl][cnto]*param.M[cnto][cntc];
  }
 
 return IM;
 
}



/*********************************************************************
*
*
*
*
*
***********************************************************************/
RobMatrix RobMatrix::operator+(const RobMatrix &param)
{
 RobMatrix IM;
 
 for(int cntl=0;cntl<4;cntl++)
  for(int cntc=0;cntc<4;cntc++)
  {
    IM.M[cntl][cntc] = M[cntl][cntc]+param.M[cntl][cntc];
  }
 
 return IM;
 
}

/*********************************************************************
*
*
*
*
*
***********************************************************************/
void RobMatrix::print()
{
	fprintf(stdout,"\n%4.4f %4.4f %4.4f %4.4f\n%4.4f %4.4f %4.4f %4.4f\n%4.4f %4.4f %4.4f %4.4f\n%4.4f %4.4f %4.4f %4.4f\n\n",
              M[0][0],M[0][1],M[0][2],M[0][3],
              M[1][0],M[1][1],M[1][2],M[1][3],
              M[2][0],M[2][1],M[2][2],M[2][3],
              M[3][0],M[3][1],M[3][2],M[3][3]);
}

/*********************************************************************
*
*
*
*
*
***********************************************************************/
RobMatrix& RobMatrix::operator=(const RobMatrix &M)
{
	for(int cntl=0;cntl<4;cntl++)
	 for(int cntc=0;cntc<4;cntc++)
	   this->M[cntl][cntc]=M.M[cntl][cntc];
	   
     this->a=M.a;
     this->d=M.d;
     this->ofth=M.ofth;
     this->alpha=M.alpha;
     
	 return (*this);	   
 }

/*********************************************************************
*
*
*
*
*
***********************************************************************/
RobMatrix RobMatrix::Inv()
{
RobMatrix Aux = *this;
    
    
    // transpose the rotation            
    Aux.M[0][0]= M[0][0];    Aux.M[0][1]= M[1][0];    Aux.M[0][2]= M[2][0]; 
    Aux.M[1][0]= M[0][1];    Aux.M[1][1]= M[1][1];    Aux.M[1][2]= M[2][1];    
    Aux.M[2][0]= M[0][2];    Aux.M[2][1]= M[1][2];    Aux.M[2][2]= M[2][2];    
   
    // delete translation
    Aux.M[0][3] = 0;    Aux.M[1][3] = 0;    Aux.M[2][3] = 0;      
    
    // translation = -R^T * P
    for( int cnt=0;cnt<3;cnt++)
    {
       Aux.M[0][3] += - M[cnt][0] *  M[cnt][3];
       Aux.M[1][3] += - M[cnt][1] *  M[cnt][3];
       Aux.M[2][3] += - M[cnt][2] *  M[cnt][3];
    }

	return Aux;
}
/*********************************************************************
*
*
*
*
*
***********************************************************************/
RobMatrix::RobMatrix(double r11, double r12, double r13,double r21, double r22, double r23,double r31, double r32, double r33)
{
    M[0][0]=r11;    M[0][1]=r12;    M[0][2]=r13;    M[0][3]=0;
    M[1][0]=r21;    M[1][1]=r22;    M[1][2]=r23;    M[1][3]=0;
    M[2][0]=r31;    M[2][1]=r32;    M[2][2]=r33;    M[2][3]=0;
    M[3][0]=0;    M[3][1]=0;    M[3][2]=0;    M[3][3]=1;
}

gsl_vector* RobMatrix::P()
{

	gsl_vector *ret = gsl_vector_calloc( 4 );
	for(int cnt=0;cnt<4;cnt++)
		gsl_vector_set(ret, cnt, M[cnt][3]);

	return ret;
}

gsl_vector* RobMatrix::getvector(int line, int column, int nelem)
{

	gsl_vector *vec = gsl_vector_alloc( nelem );

	for(int cnt = 0; cnt<nelem; cnt++)
		gsl_vector_set( vec, cnt, M[line+cnt][column] );

	return vec;
}
