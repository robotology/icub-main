// Class automatically generated by Dev-C++ New Class wizard

#include <stdio.h>
#include <stdlib.h>

#include <iCub/kinematics/robot.h> // class's header file

#include <iCub/kinematics/gsl_aux.h>

// class constructor
Robot::Robot(int njoints)
{

 m_njoints = njoints;
 m_Joints = (RobMatrix*) calloc( njoints, sizeof(RobMatrix) );
 m_uplimit = (float*) calloc( njoints, sizeof(float) );
 m_lolimit = (float*) calloc( njoints, sizeof(float) ); 
 
}

// class destructor
Robot::~Robot()
{
               
 free(m_Joints);
 free(m_uplimit);
 free(m_lolimit);
 
}

// No description
void Robot::Jacobn(double* pos, double *J)
{
RobMatrix U;

      for(int cnt = (m_njoints-1); cnt>=0; cnt--) {
              //d
              J[0*m_njoints+cnt]=-U.M[0][0]*U.M[1][3]+U.M[1][0]*U.M[0][3];
              J[1*m_njoints+cnt]=-U.M[0][1]*U.M[1][3]+U.M[1][1]*U.M[0][3];
              J[2*m_njoints+cnt]=-U.M[0][2]*U.M[1][3]+U.M[1][2]*U.M[0][3];   
              //delta
              J[3*m_njoints+cnt]=U.M[2][0];
              J[4*m_njoints+cnt]=U.M[2][1];
              J[5*m_njoints+cnt]=U.M[2][2];                            
              
              U = (m_Joints+cnt)->V(pos[cnt]) * U;
              
      }
/*
			% revolute axis
			d = [	-U(1,1)*U(2,4)+U(2,1)*U(1,4)
				-U(1,2)*U(2,4)+U(2,2)*U(1,4)
				-U(1,3)*U(2,4)+U(2,3)*U(1,4)];
			delta = U(3,1:3)';	% nz oz az
		J = [[d; delta] J];

		if robot.mdh ~= 0,
			% modified DH convention
			U = L{j}( q(j) ) * U;
		end
*/              

            

}


// returns the value of m_njoints
int Robot::Getm_njoints()
{
	return m_njoints;
}

// Set the Modified Denavitt Hartenberg parameters
void Robot::SetJoint(int joint, float al, float a, float th, float d, float lolim, float uplim)
{
      SetJoint( joint, al, a, th, d);
      m_uplimit[joint] = uplim;
      m_lolimit[joint] = lolim;
      
}
// Set the Modified Denavitt Hartenberg parameters
void Robot::SetJoint(int joint, float al, float a, float th, float d)
{

 m_uplimit[joint] = 1000;
 m_lolimit[joint] = -1000;
 
/// Isto não pode ser assim: Alex 9-3-2006
// if( (m_Joints+joint) != 0)
//   delete (m_Joints+joint);
  
 *(m_Joints+joint) = RobMatrix(al,a,th,d);
 	
}

// Forward kinematics
RobMatrix Robot::fk(double *th)
{
RobMatrix res;
     
	for (int cnt=0;cnt < m_njoints; cnt++)
    {
	    res = res * (m_Joints+cnt)->V(th[cnt]);
                //((m_Joints+cnt)->V(th[cnt])).print();
    }
     return res;   
}

// Partial Forward kinematics
RobMatrix Robot::fk(double *th, int joint)
{
RobMatrix res;
     
	for (int cnt=0;cnt < joint; cnt++)
	{
	    res = res * (m_Joints+cnt)->V(th[cnt]);

	    /* // debug porposes
	    RobMatrix aux = (m_Joints+cnt)->V(th[cnt]);
	    printf("fkine matrix %d %f\n", cnt, th[cnt]);
	    aux.print();
	    */
    }

     return res;   
}

void Robot::Jacob0(double* pos, double *J)
{
double aux,aux2;
double *Jaux;

	 Jaux = (double*)malloc( 6*m_njoints*sizeof(double) );

     Jacobn( pos, J);
     RobMatrix FK = this->fk(pos);

     for(int cc=0;cc<m_njoints;cc++)
     {
       for(int cl=0;cl<3;cl++)
       {
               aux=0;aux2=0;
               //printf("%f %f %f\n",J[0*m_njoints+cc],J[1*m_njoints+cc],J[2*m_njoints+cc]);
               for(int caux=0;caux<3;caux++)
               {
                       aux += FK.M[cl][caux] * J[caux*m_njoints+cc];
                       aux2 += FK.M[cl][caux] * J[(caux+3)*m_njoints+cc];
               }
               Jaux[cl*m_njoints+cc] = aux;
               Jaux[(cl+3)*m_njoints+cc] = aux2;
       }
     }
     
     for(int cnt=0; cnt < (m_njoints*6) ; cnt++)
       J[cnt]=Jaux[cnt];

	free( Jaux );
           
}

void Robot::Jacob0(double* pos, gsl_matrix* J)
{
double *Ja;

     Ja = (double*)malloc( 6*m_njoints*sizeof(double) );
     this->Jacob0( pos, Ja);

     for(int cl=0;cl<6;cl++)
          for(int cc=0;cc<m_njoints;cc++)     
                  gsl_matrix_set( J, cl, cc, Ja[cl*m_njoints+cc]);

	free( Ja );

}

double Robot::JacobInv0(double* pos, gsl_matrix* Jinv, float prec) {
double *Ja;
double ret;

     Ja = (double*)malloc( 6*m_njoints*sizeof(double) );
     this->Jacob0( pos, Ja);

     gsl_matrix* J = gsl_matrix_calloc( 6, m_njoints);

     for(int cl=0;cl<6;cl++)
          for(int cc=0;cc<m_njoints;cc++)     
                  gsl_matrix_set( J, cl, cc, Ja[cl*m_njoints+cc]);

     gsl_print_matrix( J, "J");

     ret = gsl_matrix_pseudoinv( J, Jinv, prec);
    
     free( Ja );
     gsl_matrix_free( J );
     
     return ret;
}

void Robot::V2Qdot(double* pos, double* V, gsl_vector* qdot, float tol) {

  gsl_vector* Vel = gsl_vector_calloc( 6 );
  gsl_vector_setfromdouble( Vel, V);
  
  V2Qdot( pos,  Vel, qdot, tol);

  gsl_vector_free( Vel );
        
}

/*
 * V2Qdot(float* pos, gsl_vector* V, gsl_vector* qdot, float tol)
 *
 *
 *
 *
 */
void Robot::V2Qdot(double* pos, gsl_vector* V, gsl_vector* qdot, float tol) {

  gsl_matrix* Jinv = gsl_matrix_calloc( 6, Getm_njoints() );
  JacobInv0( (double*)pos, Jinv, tol);       

  gsl_blas_dgemv( CblasNoTrans, 1.0, Jinv, V, 0, qdot);

  gsl_matrix_free( Jinv );  
  
}    

 
/*
 * Validates the position of the robot.
 * Returns:
 * 0 if a valid position
 * x if the joint x is above the upper limit
 * -x if the joint x is below the lower limit
 */
int Robot::ValidPosition(double *pos)
{
int ret = 0;    

	for(int cnt=0;cnt<Getm_njoints();cnt++)
	{
            if(pos[cnt]>(m_uplimit[cnt]-0.1))
            {
              //printf("+");
              ret |= (1<<cnt);
            }
            else if(pos[cnt]<(m_lolimit[cnt]+0.1))
            {
              //printf("-");
              ret |= (1<<cnt);              
            }

    }
    
    return ret;
}

int Robot::ValidPosition(gsl_vector *pos)
{
double *posa = (double*)malloc( Getm_njoints()*sizeof(double) );
int ret;

	for(int cnt = 0; cnt < Getm_njoints();cnt++)
		posa[cnt] = gsl_vector_get( pos, cnt);
	
	ret = ValidPosition( posa );

	free( posa);

	return ret;
}

RobMatrix Robot::frametransf(int joint, double value)
{
  //	RobMatrix *M = &((m_Joints+joint)->V(value));
	return ((m_Joints+joint)->V(value));
}
